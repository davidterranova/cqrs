package eventsourcing

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/rs/zerolog/log"
)

// CommandHandler should be used by the application to handle commands
type CommandHandler[T Aggregate] interface {
	// HandleCommand is the global command handler that should be called by the application
	HandleCommand(ctx context.Context, cmd Command[T]) (*T, error)

	// HydrateAggregate an aggregate from all its events (internal)
	HydrateAggregate(ctx context.Context, aggregateType AggregateType, aggregateId uuid.UUID) (*T, error)
}

// InternalCommandHandler should be used by the framework to handle commands (internal)
type InternalCommandHandler[T Aggregate] interface {
	CommandHandler[T]

	// HydrateAggregateFromEvents hydrates an aggregate from a list of events (internal)
	HydrateAggregateFromEvents(ctx context.Context, aggregateType AggregateType, events ...Event[T]) (*T, error)

	// Apply checks command validity for an aggregate and return newly related emitted events (internal)
	ApplyCommand(ctx context.Context, aggregate *T, command Command[T]) ([]Event[T], error)

	// Apply the events generated by a command to an aggregate  and return the aggregate with the new state (internal)
	ApplyEvents(ctx context.Context, aggregate *T, events ...Event[T]) (*T, error)

	// PersistEvents persists events to the event store
	// it is the responsiblitity of the event store to publish events if needed (in case of CQRS environment)
	PersistEvents(ctx context.Context, events ...Event[T]) error
}

type AggregateFactory[T Aggregate] func() *T

type commandHandler[T Aggregate] struct {
	eventStore EventStore[T]
	factory    AggregateFactory[T]
	cache      Cache[uuid.UUID, *T]
}

// NewCommandHandler creates a new command handler
// cacheOption is used to configure the command handler cache and reduce the number of calls to the event store
// if cacheOption.Disabled is set to true, the cache will be disabled
func NewCommandHandler[T Aggregate](eventStore EventStore[T], factory AggregateFactory[T], cacheOption CacheOption) *commandHandler[T] {
	cmdHandler := &commandHandler[T]{
		eventStore: eventStore,
		factory:    factory,
		cache:      NewCache[uuid.UUID, *T](cacheOption),
	}

	return cmdHandler
}

func (h *commandHandler[T]) HandleCommand(ctx context.Context, c Command[T]) (*T, error) {
	// hydrate aggregate
	aggregate, err := h.HydrateAggregate(ctx, c.AggregateType(), c.AggregateId())
	if err != nil {
		return new(T), fmt.Errorf("failed to hydrate aggregate(%s#%s): %w", c.AggregateType(), c.AggregateId(), err)
	}

	// check command validity for aggregate and retrieve result events
	events, err := h.ApplyCommand(ctx, aggregate, c)
	if err != nil {
		return new(T), fmt.Errorf("command (%T) rejected on aggregate(%s#%s): %w", c, c.AggregateType(), c.AggregateId(), err)
	}

	// apply new events to aggregate
	aggregate, err = h.ApplyEvents(ctx, aggregate, events...)
	if err != nil {
		return new(T), fmt.Errorf("failed to apply events to aggregate(%s#%s): %w", c.AggregateType(), c.AggregateId(), err)
	}

	// update cache
	h.cache.Add(c.AggregateId(), aggregate)

	// persist and publish events
	err = h.PersistEvents(ctx, events...)
	if err != nil {
		return new(T), fmt.Errorf("failed to persist and publish events for aggregate(%s#%s): %w", c.AggregateType(), c.AggregateId(), err)
	}

	// return aggregate
	return aggregate, nil
}

func (h *commandHandler[T]) HydrateAggregate(ctx context.Context, aggregateType AggregateType, aggregateId uuid.UUID) (*T, error) {
	// check if aggregate is in cache
	agg, ok := h.cache.Get(aggregateId)
	if ok {
		log.Debug().
			Str("aggregate_type", string(aggregateType)).
			Str("aggregate_id", aggregateId.String()).
			Msg("load aggregate from cache")
		return agg, nil
	}

	// load from event store
	log.Debug().
		Str("aggregate_type", string(aggregateType)).
		Str("aggregate_id", aggregateId.String()).
		Msg("load aggregate from eventstore")
	events, err := h.eventStore.Load(ctx, aggregateType, aggregateId)
	if err != nil {
		return new(T), fmt.Errorf("failed to load events for aggregate(%s#%s): %w", aggregateType, aggregateId, err)
	}

	return h.HydrateAggregateFromEvents(ctx, aggregateType, events...)
}

func (h *commandHandler[T]) HydrateAggregateFromEvents(ctx context.Context, aggregateType AggregateType, events ...Event[T]) (*T, error) {
	// create new aggregate
	aggregate := h.factory()

	// apply events
	for _, event := range events {
		err := event.Apply(aggregate)
		if err != nil {
			return new(T), fmt.Errorf("failed to apply event(%s) to aggregate(%s#%s): %w", event.EventType(), aggregateType, (*aggregate).AggregateId(), err)
		}
	}

	// return aggregate
	return aggregate, nil
}

func (h *commandHandler[T]) ApplyCommand(ctx context.Context, aggregate *T, c Command[T]) ([]Event[T], error) {
	agg := *aggregate
	// check if command is valid for aggregate and generate events
	events, err := c.Apply(aggregate)
	if err != nil {
		return nil, fmt.Errorf("command (%T) is invalid for aggregate(%s#%s): %w", c, agg.AggregateType(), agg.AggregateId(), err)
	}

	// return events
	return events, nil
}

func (h *commandHandler[T]) ApplyEvents(ctx context.Context, aggregate *T, events ...Event[T]) (*T, error) {
	for _, event := range events {
		err := event.Apply(aggregate)
		if err != nil {
			return new(T), fmt.Errorf(
				"failed to apply event(%s) to aggregate(%s#%s): %w",
				event.EventType(),
				(*aggregate).AggregateType(),
				(*aggregate).AggregateId(),
				err,
			)
		}
	}

	// return aggregate
	return aggregate, nil
}

// PersistEvents persists events to the event store
// it is the responsiblitity of the event store to publish events if needed (in case of CQRS environment)
func (h *commandHandler[T]) PersistEvents(ctx context.Context, events ...Event[T]) error {
	err := h.eventStore.Store(ctx, events...)
	if err != nil {
		return fmt.Errorf("failed to store events: %w", err)
	}

	return nil
}
